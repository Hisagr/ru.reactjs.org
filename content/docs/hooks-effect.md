---
id: hooks-state
title: Использование хука эффекта
permalink: docs/hooks-effect.html
next: hooks-rules.html
prev: hooks-intro.html
---

*Хуки* -- это новое дополнение в React 16.8. С их помощью, вы можете использовать состояние и другие функции React без создания классов.

*Хук эффекта* дает вам возможность выполнять побочные эффекты в функциональном компоненте:

```js{1,6-10}
import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  // По принципу componentDidMount и componentDidUpdate:
  useEffect(() => {
    // Update the document title using the browser API
    document.title = `You clicked ${count} times`;
  });

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

Этот фрагмент основан на [примере со счетчиком из предыдущей страницы](/docs/hooks-state.html), но мы добавили новый функционал туда: мы меняем заголовок документа на пользовательское сообщение, которое также содержит количество нажатий кнопки.

Побочными эффектами в React компонентах могут быть: загрузка данных, оформление подписки и изменение DOM вручную. Неважно называете ли вы эти операции "побочными эффектам" (или просто "эффектами") или нет, вам скорее всего доводилось ранее использовать их в своих компонентах.

>Совет
>
>Если вам знакомы класовые методы жизненного цикла React, Хук `useEffect` представляет собой совокупность методов `componentDidMount`, `componentDidUpdate`, и `componentWillUnmount`.

Существует два распространенных вида побочных эффектов в компонентах React: компоненты, которые требуют и не требуют "подчистки". Давайте рассмотрим оба примера более детально.

## Эффекты без подчистки {#effects-without-cleanup}

Иногда, мы хотим **выполнить некий дополнительный код после того как React обновил DOM.** Сетевые запросы, изменения DOM вручную и  логирование -- всё это примеры эффектов, которые не требуют подчистки. После того как мы запустили их, можно сразу забыть о них, ведь больше никаких дополнительных действий не требуется. Давайте сравним как классы и Хуки позволяют нам реализовывать побочные эффекты.

### Пример с использованием классов {#example-using-classes}

В классовых компонентах React, метод `render` сам по себе не должен вызывать никаких побочных эффектов. Он не подходит для этих целей, так как, обычно, мы хотим выполнить наши эффекты *после* того как React обновил DOM.

Вот, почему в классах React, мы кладем побочные эффекты внутрь `componentDidMount` и `componentDidUpdate`. Возвращаясь к нашему примеру, здесь представлен счетчик, реализованый с помощью класового компонента React. Он обновляет заголовок документа сразу же после того как React вносит изменения в DOM:

```js{9-15}
class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  componentDidMount() {
    document.title = `You clicked ${this.state.count} times`;
  }

  componentDidUpdate() {
    document.title = `You clicked ${this.state.count} times`;
  }

  render() {
    return (
      <div>
        <p>You clicked {this.state.count} times</p>
        <button onClick={() => this.setState({ count: this.state.count + 1 })}>
          Click me
        </button>
      </div>
    );
  }
}
```

Обратите внимание, что **нам приходится дублировать наш код между этими класовыми методами жизненного цикла**

Это всё потому, что во многих случаях, мы хотим выполнять одни и те же побочные эффекты, вне зависимости от того, был ли компонент только что смонтирован или обновлен. В основном, мы хотим, чтобы они выполнялись после каждого рендера -- но у классовых компонентов React нет таких встроенных методов. Мы могли бы вынести этот метод отдельно, но нам бы всёравно пришлось бы вызывать его в двух местах.

А сейчас, давайте посмотрим как мы можем сделать тоже самое с использованием Хука `useEffect`.

### Пример с использованием хуков {#example-using-hooks}

Мы уже рассматривали этот пример немого ранее, но давайте разберем его более подробно:

```js{1,6-8}
import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `You clicked ${count} times`;
  });

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

**Что же делает `useEffect`?** Используя этот Хук, вы указываете на то, что React должен сделать что-то после рендера. React запомнит функцию, которую вы передали (мы будем ссылаться на нее как наш "эффект") и вызвет ее после того как внесет все изменения в DOM. В этом эффекте мы устанавливаем заголовок документа, но мы также можем выполнить запрос данных или вызвать какой-нибудь императивный API.

**Почему же мы вызываем `useEffect` непосредственно внутри компонента?** Это дает нам доступ к переменной состояния `count` (или любым другим пропсам) прямиком из эффекта. Нам не нужен некий особый API, чтобы иметь доступ к этой переменной -- она уже находится у нас в области видимости функции. Хуки используют замыкания JavaScript, и таким образом, им не нужны особые React API, так как сам JavaScript уже имеет готовое решение для этой задачи.

**Выполняется ли `useEffect` после каждого рендера?** Разумеется! По умолчанию, он будет выполняться после каждого рендера и обновления. (Мы рассмотрим [как настраивать это](#tip-optimizing-performance-by-skipping-effects) немного позже.) Вместо того, чтобы воспринимать это с позиции "монтирования" и "обновления", мы советуем просто иметь в виду, что эффекты происходят после каждого рендера. React гарантирует, что он запустит эффект только после того, как DOM уже будет обновлен.

### Подробное объяснение {#detailed-explanation}

Мы узнали немного больше о принципе работы эффектов, и теперь, этот код уже вовсе не кажется таким непонятным:

```js
function Example() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `You clicked ${count} times`;
  });
```

Мы объявляем переменную состояния `count` и говорим React, что мы хотим использовать эффект. Далее, мы передаем фунцию в Хук `useEffect`. Эта функция как раз и будет нашим эффектом. Внутри нашего эффекта, мы устанавливаем заголовок документа используя API браузера `document.title`. Мы можем получать доступ к актуальной переменной `count` изнутри эффекта, так как он находится в областе видимости нашей функции. Когда React рендерит наш компонент, он запоминает эффект, который мы использовали, и запускает его после того, как обновит DOM. Это будет происходить при каждом рендере, в том числе и при первоначальном.

Опытные JavaScript разработчики могут подметить, что функция, которую мы передаем в `useEffect`, будет меняться при каждом рендере. На самом деле, это было сделано преднамеренно. Это как раз то, что дает нам возможность получать актуальную версию переменной `count` изнутри эффекта, не беспокоясь о том, что ее значение устареет. Каждый раз при повторном рендере, мы ставим в очередь _новый_ эффект, который заменяет предыдущий. В какой-то степени, это дает возможность эффекту отоноситься непосредственно к результату рендера, так как каждый эффект "относится" к определённому рендеру. Мы расскажем о преимуществах данного подхода [далее на этой странице](#explanation-why-effects-run-on-each-update).

>Совет
>
>В отличии от `componentDidMount` или `componentDidUpdate`, эффекты, запланированные с помощью `useEffect`, не блокируют браузер при попытке обновить экран. Ваше приложение будет быстрее реагировать на действия пользователя, даже когда эффект ещё не закончился. Большинству эффектов не нужно работать в синхронном режиме. Есть редкие случаи, когда им всё же нужно это делать (например измерять раскладку), но для этого мы разработали специальный Хук [`useLayoutEffect`](/docs/hooks-reference.html#uselayouteffect) с точно такии же API как и у `useEffect`.

## Эффекты с подчисткой {#effects-with-cleanup}

Ранее, мы рассмотрели побочные эффекты, который не требуют подчистки. Однако, есть случаи, когда подчистка все же необходима. Например, **нам может потребоваться оформить подписку** на некий внешний источник данных. В этом случае, очень важно выполнять подчистку, чтобы не случилось утечек памяти! Давайте сравним как мы можем это реализовать с помощью классов и Хуков.

### Пример с использованием классов {#example-using-classes-1}

В React классе, вы, как правило, оформили бы подписку в `componentDidMount`, и отменили бы её в `componentWillUnmount`. Например, предположим, что у нас есть некий `ChatAPI` модуль, с помощью которого мы можем подписаться на статус друга в сети. Вот как мы бы подписались и отобразили бы статус используя класс:

```js{8-26}
class FriendStatus extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isOnline: null };
    this.handleStatusChange = this.handleStatusChange.bind(this);
  }

  componentDidMount() {
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  handleStatusChange(status) {
    this.setState({
      isOnline: status.isOnline
    });
  }

  render() {
    if (this.state.isOnline === null) {
      return 'Loading...';
    }
    return this.state.isOnline ? 'Online' : 'Offline';
  }
}
```

Обратите внимания, что `componentDidMount` и `componentWillUnmount` по сути содержат идентичный код. Методы жизненного цикла вынуждают нас разбивать эту логику, хоть и фактически, код обоих методов относится к одному и тому же эффекту.

>Примечание
>
>Вы могли заметить, что для правильной работы, нашему компоненту также нужен `componentDidUpdate`. Мы пока упустим этот момент и раскажем об этом подробнее в [следующей главе](#explanation-why-effects-run-on-each-update) на этой странице.

### Пример с использованием хуков {#example-using-hooks-1}

Давайте рассмотрим как этот компонент будет выглядеть, если написать его с помощью Хуков.

Вы должно быть подумали, что нам потребуется отдельный эффект для выполения подчистки. Так как код для оформления и отмены подписки тесно связан с `useEffect`, мы решили объединить это всё вместе. Если ваш эффект возвращает функцию, React выполнит ее тогда, когда наступит время подчистить после эффекта.

```js{10-16}
import React, { useState, useEffect } from 'react';

function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null);

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }

  useEffect(() => {
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    // Specify how to clean up after this effect:
    // Указываем как подчистить после этого эффекта:
    return function cleanup() {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  if (isOnline === null) {
    return 'Loading...';
  }
  return isOnline ? 'Online' : 'Offline';
}
```

**Зачем мы вернули функцию из нашего эффекта?** Это необязательный механизм подчистки эффектов. Каждый эффект может возвратить функцию, которая подчистит после него. Это дает нам возможность объединить вместе логику оформления и отмены подписки. Они, все-таки, часть одного и того же эффекта!

**Когда именно React будет подчищать после эффекта?** React будет подчищать перед тем, как компонент размонтируется. Однако, как мы уже знаем, эффекты выполняются при каждом рендер, а не один лишь раз. Это как раз и есть причиной, почему React *также* подчищает после эффекта из предыдущего рендера, перед тем как запустить следующий. Мы рассмотрим [почему это позволяет избежать багов](#explanation-why-effects-run-on-each-update) и [как отказаться от этой логики, если это вызывает проблемы с производительностью](#tip-optimizing-performance-by-skipping-effects) далее.

>Совет
>
>Нам не нужно возвращать именнованую функцию из эффекта. Мы назвали ее "подчисткой", чтобы объяснить ее предназначение. Вы можете по желанию возвратить стрелочную функцию или назвать ее как-то по другому.

## Подитожим {#recap}

Мы узнали, что с помощью `useEffect`, мы можем вызывать разные побочные эффекты после того, как компонент отрендерится. Некоторым эффектам нужна подчистка, поэтому они вощвращают соответствующую функцию.

```js
  useEffect(() => {
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });
```

В некоторыъ эффектах нет этапа подчистки, поэтому они не вовращают ничего.

```js
  useEffect(() => {
    document.title = `You clicked ${count} times`;
  });
```

Хук эффекта объединяет в себе всю необходимую логику в едином API.

-------------

**Если вы чувствуете, что вы достаточно разобрались с тем, как работает Хук эффекта или если вы немного подустали, вы можете отправиться [на страницу о правилах хуков](/docs/hooks-rules.html) прямо сейчас.**

-------------

## Советы по использованию эффектов {#tips-for-using-effects}

Сейчас, давайте углубимся в некоторые особенности Хука `useEffect`, о которых опытные пользователи React наверняка уже задумались. Пожалуйста, не заставляйте себя углубляться в эти особенности прямо сейчас. Вы можете сперва закрепить вышепройденный материал и вернуться сюда позже в любой момент.

### Совет: используйте разные хуки для разных задач {#tip-use-multiple-effects-to-separate-concerns}

Один из ключевых моментов, которые мы описали в [мотивации](/docs/hooks-intro.html#complex-components-become-hard-to-understand), приводит аргументы о том, что в отличии от Хуков, классовые методы жизненного цикла часто содержат логику, которая никак между собой не связанна, в то время как связанная логика, разбивается на несколько методов. Далее мы приведем пример компонента, который объединяет в себе логику счетчика и индикатора статуса нашего друга из предыдущих примеров:

```js
class FriendStatusWithCounter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0, isOnline: null };
    this.handleStatusChange = this.handleStatusChange.bind(this);
  }

  componentDidMount() {
    document.title = `You clicked ${this.state.count} times`;
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentDidUpdate() {
    document.title = `You clicked ${this.state.count} times`;
  }

  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  handleStatusChange(status) {
    this.setState({
      isOnline: status.isOnline
    });
  }
  // ...
```

Обратите внимание, что логика, которая устанавливает `document.title` разбита между `componentDidMount` и `componentDidUpdate`. Логика подписки также раскидана между `componentDidMount` и `componentWillUnmount`. А метод `componentDidMount` включает в себя логику для обеих задач.

Как же можно решить эту проблему с помощью Хуков? Точно так же, как [вы можете использовать Хук *состояния* более одного раза](/docs/hooks-state.html#tip-using-multiple-state-variables), вы также можете использовать и несколько эффектов. Это дает нам возможность разделять разную несвязанную между собой логику между разными эффектами.

```js{3,8}
function FriendStatusWithCounter(props) {
  const [count, setCount] = useState(0);
  useEffect(() => {
    document.title = `You clicked ${count} times`;
  });

  const [isOnline, setIsOnline] = useState(null);
  useEffect(() => {
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }
  // ...
}
```

**С помощью хуков, мы можем разделить наш код основываясь на том, что он делает**, а не по принципам методов жизненного цикла. React будет выполнять *каждый* используемый эффект в компоненте, согласно порядку их объявления.

### Объяснение: Почему эффекты выполняются при каждом обновлении {#explanation-why-effects-run-on-each-update}

Если вы привикли пользоваться классами, вы должно быть думаете, почему этап подчистки эффекта происходит после каждого последующего рендера, а не один лишь раз во время размонтировки. Давайте расмотрим на практике, почему именно этот способ дает нам возможность избежать некоторых багов в наших компонентах.

[Ранее на этой странице](#example-using-classes-1), мы рассматривали пример с коспонентом `FriendStatus` , который отображает в сети наш друг или нет. Наш класс берет `friend.id` из `this.props`, подписывается на статус друга после того, как компонент смонтировался, и отписывается от него во время размонтировки.

```js
  componentDidMount() {
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }
```

**Но что же произойдет, если проп `friend` поменяется**, пока компонент все еще находится на экране? Наш компонент будет отображать статус в сети уже какого-нибудь другого друга. Это как раз таки баг. Это также может привести к утечки памяти или вообще к вылету нашего приложения при размонтировке, так как метод отписки будет использовать неправильный ID друга, от которого мы хотим отписаться.

В классовом компоненте, нам бы пришлось добавить `componentDidUpdate`, чтобы решить эту задачу:

```js{8-19}
  componentDidMount() {
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentDidUpdate(prevProps) {
    // Отписаться от предыдущего friend.id
    ChatAPI.unsubscribeFromFriendStatus(
      prevProps.friend.id,
      this.handleStatusChange
    );
    // Подписаться на следующий friend.id
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }
```

Забывать использовать `componentDidUpdate` надлежащим образом -- это один из самых распространенных источников багов в приложениях React.

Теперь давайте рассмотрим версию этого же компонента, но уже написаного с использованием Хуков:

```js
function FriendStatus(props) {
  // ...
  useEffect(() => {
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });
```

It doesn't suffer from this bug. (But we also didn't make any changes to it.)
Этого бага в данном компонент нет. (Но мы также не изменили ничего там)

Здесь нет никакого особого кода для решения проблем с обновлениями, так как `useEffect` решает их *по умолчанию*. Он подчищает предыдущие эффекты прежде чем выполнить новые. Чтобы показать это на практике, давайте рассмотрим последовательность подписок и отписок, которые этот компонент может выполнить в течении некоторого времени.

```js
// Монтируем с пропсами { friend: { id: 100 } } 
ChatAPI.subscribeToFriendStatus(100, handleStatusChange);     // Выполняем первый эффект

// Обновляем с пропсами { friend: { id: 200 } }
ChatAPI.unsubscribeFromFriendStatus(100, handleStatusChange); // Подчищаем предыдущий эффект
ChatAPI.subscribeToFriendStatus(200, handleStatusChange);     // Выполняем следующий эффект

// Обновляем с пропсами { friend: { id: 300 } }
ChatAPI.unsubscribeFromFriendStatus(200, handleStatusChange); // Подчищаем предыдущий эффект
ChatAPI.subscribeToFriendStatus(300, handleStatusChange);     // Выполняем следующий эффект

// Размонтируем
ChatAPI.unsubscribeFromFriendStatus(300, handleStatusChange); // Подчищаем последний эффект
```

Эта логика по умолчаниию гарантирует согласованность выполняемых нами действий и исключает баги, которые довольно распространенны в классовых компонентах из-за отсутствия логики обновления.

### Совет: Оптимизация производительность за счет пропуска эффектов {#tip-optimizing-performance-by-skipping-effects}

В некоторых случаях, подсчистить или выполнить эффект при каждом рендере может вызвать проблем с производительностью. В классовых компонентах, мы можем решить эту проблему используя дополнительное сравнение `prevProps` или `prevState` внутри `componentDidUpdate`:

```js
componentDidUpdate(prevProps, prevState) {
  if (prevState.count !== this.state.count) {
    document.title = `You clicked ${this.state.count} times`;
  }
}
```

Это логику приходиться использовать довольно часто, поэтому мы решили встроить её в API Хука `useEffect`. Вы можете сделать так, чтобы React *пропускал* вызовк эффекта, если определенные значения не поменялись между последующими рендерами. Чтобы сделать это, передайте массив в `useEffect` вторым необезательным аргументом.

```js{3}
useEffect(() => {
  document.title = `You clicked ${count} times`;
}, [count]); // Перезапускать эффект только если count поменялся
```

В этом примере, мы передаем `[count]` вторым аргументом. Что это вообще значит? Это значит, что если `count` будет равен `5` и наш компонент повторно рендерится с тем же значением `count` = `5`, React сравнит `[5]` из предыдущего рендера и `[5]` ис следующего рендера. Так как, все элементы массива осталис без изменений (`5 === 5`), React пропустит этот эффект. Это и есть оптимизация данного процесса.

Когда при следующем рендере наша переменная `count` обновится до `6`, React сравнит элементы в массиве `[5]` из предыдущего рендера и элементы массива `[6]` из следующего рендера. На этот раз, React выполнит наш эффект, так как `5 !== 6`. Если у вас будет несколько элементов в массиве, React будет выполнять наш эффект, в том случае, когда хотя бы один из них будет отличаться.

Это также работает для эффектов с этапом подчистки:

```js{6}
useEffect(() => {
  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
  return () => {
    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
  };
}, [props.friend.id]); // Only re-subscribe if props.friend.id changes
```

В будущем, второй аргумент может будет добавлен автоматически с помощью трансформации во время выполнения.

>Примечание
>
>Если вы хотите использовать эту оптимизацию, обратите внимание на то, чтобы элементом массива была **любая переменная из внешней области видимости, которая будет меняться через время, и которая будет использоваться эффектом**. В противном случае, ваш код будет ссылаться на устаревшее значение из предыдущих рендеров. Мы рассмотрим другие возможные оптимизации на странице [справочник API хуков](/docs/hooks-reference.html). 
>
>Если вы хотите выполнять эффект и подчищать его только раз (при монтировке и размонтировке), вы можете передать пустой массив вторым аргументом. React посчитает, что ваш эффект не зависит от *каких-либо* зачений из пропсов или состояния, и таким образом, он будет знать, что ему не надо его выполнять повторно. Это не расценивается как особый случай -- он напрямую следует из логики работы массивов при вводе. Хотя передача `[]` ближе по мысли к модели знакомых `componentDidMount` и `componentWillUnmount`, мы не советуем привыкать к этому, так как это часто приводит к багам, [как было рассмотрено ранее](#explanation-why-effects-run-on-each-update). Не забывайте, что React откладывает выполнение `useEffect` пока браузер не отрисует все изменения, поэтому выполнение дополнительной работы не является существенной проблемой.

## Next Steps {#next-steps}

Поздравляем! Это была длинная страница, но мы надеемся, что под конец, у нас получилось ответить на все ваши вопросы по поводу работы эффектов. Вы уже узнали о Хуке состояния и о Хуке эффекта, и теперь есть *очень много* вещей, которые вы можете делать объединив их вместе. Они покрывают большую часть проблем, которые решаются с помощь классов. В остальных случаях, вам могут пригодиться [дополнительные хуки](/docs/hooks-reference.html)

Мы также начинаем замечать как Хуки решают проблемы описанные в [мотивации](/docs/hooks-intro.html#motivation). Мы увидели как с помощью подчистки после эффектов нам удается избежать дупликатов в `componentDidUpdate` и `componentWillUnmount`, объединить связанный код вместе и защитить наш код от багов. Мы также рассмотрели как можно разделять наши эффекты по смыслу и назначению, что ранее вовсе не возможно было сделать в классах.

На этом этапе, вы, возможно, задаетесь вопросом, как Хуки работают в целом. Как React понимает какая переменная состояния соответствует какому вызову `useState` между повторными рендерами? Как React "сопоставляет" предыдущие и следующие эффекты при каждом обновлении? **На следующей странице, мы узнаем о [правилах Хукво](/docs/hooks-rules.html), так как они являются залогом корректной работы Хуков.**
